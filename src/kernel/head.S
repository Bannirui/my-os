// 内核的头程序 在loader中已经从16位实模式跳到32位保护模式 以及临时切换到IA-32e长模式
// 现在到了内核程序中了 需要依赖内核头程序为系统重建64位IA-32e长模式的段结构和页表结构
// 代码风格是AT&T
// 在链接的时候把0xffff800000000000+0x100000设计成了内核程序的线性地址
.section .text

.globl _start
// GAS编译器将_start作为程序默认的起始位置
_start:
    // 准备重建GDT和IDT结构 设置数据段选择子
    mov $0x10, %ax // 0x10高13位是2 设置数据段选择子 对应的GDT表索引是2
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %ss
    mov $0x7e00, %esp // 栈倒扣在这个位置往下增长 把栈临时设置在这个位置过渡一下

    lgdt GDT_POINTER(%rip) // rip是相对寻址 取GDT_POINTER的内容作为GDTR GDTR会拿到那个地方10字节的信息 等于是知道了GDT表的起始和表长
    // 此时执行完lgdt GDT表已经就绪 但是CS还是旧的 没有更新 需要搭配一个far jump或者far call来刷新cs里面的代码段选择子

    lidt IDT_POINTER(%rip)
    // 再次设置数据段寄存器并把栈切换为64位风格的寄存器
    mov $0x10, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    mov %ax, %ss
    movq $0x7e00, %rsp

    movq $0x101000, %rax // 内核的程序被loader加载到内存时->缓存到0x7e00->搬运到0x100000 下面布局PML的时候把PML4的相对内核头程序偏移定为1000 所以PML4的物理地址就是101000 告诉cr3寄存器PML4的物理地址在哪
    movq %rax, %cr3
    movq switch_seg(%rip), %rax // 把switch_seg这个64位目标地址读到rax寄存器
    pushq $0x08 // GDT表代码段的选择子入栈
    pushq %rax // switch_seg地址入栈
    lretq // 栈顶依次是switch_seg地址 段选择子 lretq指令等价于pop rip; pop cs; 一下子就把cs和ip都刷新了 完成了64位的切换

// 执行到这的时候已经是在64位模式下了
switch_seg:
    .quad entry64

entry64:
    movq $0x10, %rax
    movq %rax, %ds
    movq %rax, %es
    movq %rax, %gs
    movq %rax, %ss
    movq $0xffff800000007e00, %rsp // 上面临时设置了栈在7e00 在平坦模型下低地址空间将来都是划分给用户程序的 现在正式把内核的栈设置成对应的逻辑地址 内核空间的划分是在64位高半区 内核的物理起始地址是0x100000 映射的逻辑地址是0xffff800000000000 所以现在栈的物理地址是0x7e00映射的逻辑地址就是0xffff800000007e00

    movq go_to_kernel(%rip), %rax
    pushq $0x08 // 物理代码段选择子
    pushq %rax // go_to_kernel标号地址
    lretq // pop rip; pop cs; 刷新cs和ip完成执行跳转 也就是在64位长模式下跳转到内核主程序去执行

go_to_kernel:
    .quad Start_Kernel // 内核头程序跳到内核主程序Start_Kernel函数中

// 为操作系统创建和初始化页表及页表项
.align 8 // 在64位IA-32e长模式下 页表被分为4个等级 每个页表项是8字节 所以用align将对齐标准设置为8字节

// 页表项的格式
//   63              12   11       9     8     7     6     5     4     3     2     1     0
//+--------------------+---------------+-----+-----+-----+-----+----------+-----+-----+-----+
//|       物理地址      |      AVL      |  G  |  PS |  D  |  A  |    PWT   |  U  |  R  |  P  |
//+--------------------+---------------+-----+-----+-----+-----+----------+-----+-----+-----+
// G-全局页
// PS-页大小 三层页表表示2MB 二层页表表示1G
// D-已修改 在四层页表才有意义 脏页
// A-已访问
// PWT-缓存控制
// U-用户态可访问
// R-可写
// P-是否存在
.org 0x1000 // 指定页表的起始地址 固定各个页表的起始地址 相对内核头程序起始地址偏移多少的地方
// 内核代码被放在物理地址0x100_000上 那么PML4就是在物理地址0x101_000上
__PML4E: // page map level 4 顶层页表 512项 顶层页表从物理地址0x101_000开始 占1M
    .quad 0x102007 // PML4[0]=低地址空间 从虚拟地址0开始
    .fill 255,8,0
    .quad 0x102007 //PML4[256]=高地址空间 从虚拟地址0xffff800000000000开始
    .fill 255,8,0
// 在顶层页表中2个页目录指向同一个二层页表的原因是保证CPU模式切换过程中 内核只需要低地址+高半区 没必要全覆盖
.org 0x2000
__PDPTE: // page directory pointer table 二层页表 512项 二层页从物理地址0x102_000开始 占1M
    .quad 0x103003 // 在顶层页表中低地址和高半区的页表项物理地址都是这个 抹掉低12位就是0x103_000这个物理地址找到3层页表
    .fill 511,8,0

.org 0x3000
__PDE: // page directory 三层页表 512项 三层页表从0x103_000开始 占1M
// 三层页表项的低12位属性0x83对应二进制是0000_1000_0011 PS=1表示三层页表项表达的是2MB
    .quad 0x000083 // 抹掉低12位 表达2MB物理地址[0...0x001FFFFF]
    .quad 0x200083 // 抹掉低12位 表达2MB物理地址[0x00200000...0x003FFFFF]
    .quad 0x400083 // 抹掉低12位 表达2MB物理地址[0x00400000...0x005FFFFF]
    .quad 0x600083 // 抹掉低12位 表达2MB物理地址[0x00600000...0x007FFFFF]
    .quad 0x800083 // [0x800000...0x009FFFFF]
    .quad 0xe0000083 // [0xe0000000...E01FFFFF]
    .quad 0xe0200083 // [0xe0200000...E03FFFFF]
    .quad 0xe0400083 // [0xe0400000...E05FFFFF]
    .quad 0xe0600083 // [0xe0600000...E07FFFFF]
    .quad 0xe0800083 // [0xe0800000...E09FFFFF]
    .quad 0xe0a00083 // [0xe0a00000...E0BFFFFF]
    .quad 0xe0c00083 // [0xe0c00000...E0DFFFFF]
    .quad 0xe0e00083 // [0xe0e00000...E0FFFFFF]
    .fill 499,8,0
// 在三层页表中用2MB大页表达了3600G的物理内存

// 数据段 把全局描述符表GDT结构 中断描述符表IDT结构 任务状态段TSS结构都放在内核程序的数据段内
.section .data
.globl GDT_Table
// 正式规划的GDT表 段选择子偏移是高13 也就是说段落选择子可以检索的GDT表索引是[0...(1<<13)-1] 总共有1<<13个表项
// 规划了GDT表的规模是17个表项 后10个全部用0占位
//   15    14    13    12    11    10    9     8     7     6     5     4     3     2     1     0
//+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
//|                   Base[31:24]                 |  G  | D/B |  L  | AVL |      Limit[19:16]     |
//+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
//|  P  |     DPL   |  S  |  E  |  DC | RW  |  A  |              Base[23:16]                      |
//+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
//|                                     Base[15:0]                                                |
//+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
//|                                    Limit[15:0]                                                |
//+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
// 64位下段的概念已经没有了 依然保留段描述符的意义 1是兼容历史和保证过渡 2是用段描述符中的其他标识位
// G-粒度 64位下忽略 置0就行 0-字节 1-4K
// D/B-64位置0
// L-1表示64位代码段
// AVL-可用
// P-1表示段存在
// DPL-特权级 ring0 ring3
// S-0表示系统段比如LDT/TSS 1表示代码段/数据段
// E-0表示数据段 1表示代码段
// DC-数据段表示向上/向下扩展 代码段表示一致性
// RW-1表示可读写 0-表示可读
// A-已访问
GDT_Table:
    .quad 0x0000000000000000 // 跟32位保护模式下一样 表的第1个是空的标识作用
    .quad 0x0020980000000000 // 内核代码段 G=0 D/B=0 L=1 AVL=0 P=1 DPL=00 S=1 E=1 DC=0 RW=0 A=0
    .quad 0x0000920000000000 // 内核数据段 G=0 D/B=0 L=0 AVL=0 P=1 DPL=00 S=1 E=0 DC=0 RW=1 A=0
    .quad 0x0020f80000000000 // 用户代码段 G=0 D/B=0 L=1 AVL=0 P=1 DPL=11 S=1 E=1 DC=0 RW=0 A=0
    .quad 0x0000f20000000000 // 用户数据段 G=0 D/B=0 L=0 AVL=0 P=1 DPL=11 S=1 E=0 DC=0 RW=1 A=0
    .quad 0x00cf9a000000ffff // 32位代码段 G=1 D/B=1 L=0 AVL=0 P=1 DPL=11 S=1 E=1 DC=0 RW=1 A=0 32位兼容模式代码是可读写的 在32位模式下还是需要段基址和段界限的
    .quad 0x00cf92000000ffff // 32位数据段 G=1 D/B=1 L=0 AVL=0 P=1 DPL=11 S=1 E=0 DC=0 RW=1 A=0 32位兼容模式 在32位模式下还是需要段基址和段界限的
    .fill 10,8,0
GDT_END:

// 跟32位下的GDT表结构一样 区别在表地址 32位下地址4字节 64位下地址8字节
// 要告诉gdtr 10字节 2字节是表长(GDT表字节数-1)和8字节的GDT表地址
GDT_POINTER:
GDT_LIMIT: .word GDT_END - GDT_Table - 1 // 2字节
GDT_BASE: .quad GDT_Table // 4字节

.globl IDT_Table
IDT_Table:
    .fill  512,8,0
IDT_END:

IDT_POINTER:
IDT_LIMIT: .word IDT_END - IDT_Table - 1
IDT_BASE: .quad IDT_Table

.globl TSS64_Table
TSS64_Table:
    .fill  13,8,0
TSS64_END:

TSS64_POINTER:
TSS64_LIMIT: .word TSS64_END - TSS64_Table - 1
TSS64_BASE: .quad TSS64_Table