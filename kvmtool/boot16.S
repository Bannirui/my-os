// 使用gcc编译器汇编程序时 如果遇到以大写S作为扩展名的汇编文件时
// gcc在调用汇编器之前 将首先调用预处理程序处理汇编文件中的预处理指令
// 因此使用S扩展名可以使用C语言中的预处理语法

// 16位实模式
.text
.code16

// 1 创建保护模式的段描述符文表
// 2 告知处理器段描述符表地址
// 3 开启处理器保护模式
// 4 跳转到内核保护模式

start16:
    # 内核在初始化过程中还没做好处理外部中断的准备 因此在开启初始化过程前先使用指令cli清除掉标志寄存器中的中断位 告知处理器不要响应外部中断
    # 实模式和保护模式只是过渡模式 因此在这两个模式下不处理中断 知道64位模式准备好响应中断
    cli

    # x86处理器提供了专用指令ldgt从内存中家在段描述符表地址到寄存器GDTR
    # x86处理器使用一个寄存器GDTR来记录段描述符表的地址
    # 保护模式下寄存器GDTR长度为48位
    # 47          16 15           0
    # [段描述符地址][段描述符表长度]
    lgdt gdtr

    # 准备好段描述符表之后就可以开启保护模式了 处理器中控制寄存器CR0第0位PE用于控制处理器是否开启保护模式
    # CR0是32位的 先将CR0内容读取到寄存器中 然后最后一位置1 再写回CR0
    mov %cr0, %eax
    or $0x1, %eax
    mov %eax, %cr0

    # 处理器已经处于了保护模式 但是处理器还在运行内核实模式部分的指令 处理器不允许程序直接修改指令指针寄存器 所以要准备好保护模式部分的程序 通过跳转指令完成从实模式跳转到保护模式
    # 要跳转到保护模式 需要完成两件事情
    # 1 更新代码段寄存器CS 之前处于实模式 CS中存储的是一个段基址 切换到保护模式后 CS需要存储的是内核代码段在段描述符表中的索引
    # 2 指令指针指向保护模式入口处的指令
    # 系统软件可以操作的是段寄存器的高16位 段选择子
    # 15  3     2    1 0
    # 段索引 TI标识 特权级
    #   1       0     00
    # 00000000000001 0 00
    # 0x8
    # 从实模式部分跳转到保护模式部分涉及到不同段间跳转 x86将其称为长跳转 AT&T语法提供了长跳转指令ljmpl
    # l long 表示长跳转
    # jmp 跳转指令
    # l long 表示地址是32位的
    # ljmpl接收2个操作数
    # 第一个操作数是段选择子
    # 第二个操作数是段内偏移地址 保护模式的入口地址是0x20000 段基址是0 所以段内偏移是x020000
    ljmpl $0x8, $0x20000

# 创建保护模式的段描述符表
gdt:
    # quad伪指令向当前内存位置写入64位整数值
    # 段描述符表的每个表项64bit 8byte
    # x86处理器约定段描述符表的第0项保留不用 所以将第0项设置为0
    .quad 0x0000000000000000
    # 第1项定义内核代码段
    .quad 0x00c09a00000007ff
    # 第2项定义内核数据段
    .quad 0x00c09200000007ff
gdt_end:

# 定义48位的变量 高32位存放段描述符表的地址 低16位存放段描述符表的长度(段描述符表有多少个byte)
gdtr:
    # 低16位
    .word gdt_end - gdt
    # 高32位 存放段描述符表的地址 kvmtool初始化的各个段寄存器值为0x1000 因此段描述符的地址=DS<<4+gdt=0x10000+gdt
    # 47 32 31 16 15 0
    # [0x1] [gdt][长度]
    .word gdt, 0x1
